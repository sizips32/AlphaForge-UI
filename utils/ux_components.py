"""
UX Í∞úÏÑ† Ïª¥Ìè¨ÎÑåÌä∏ ÎùºÏù¥Î∏åÎü¨Î¶¨
Ìñ•ÏÉÅÎêú ÏÇ¨Ïö©Ïûê Í≤ΩÌóòÏùÑ ÏúÑÌïú Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Ïª¥Ìè¨ÎÑåÌä∏Îì§
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from typing import Dict, List, Any, Optional, Union, Callable, Tuple
from datetime import datetime, timedelta
import time
import uuid
from dataclasses import dataclass
from enum import Enum
import json
import asyncio

class NotificationType(Enum):
    SUCCESS = "success"
    WARNING = "warning"
    ERROR = "error"
    INFO = "info"

class ToastPosition(Enum):
    TOP_RIGHT = "top-right"
    TOP_LEFT = "top-left"
    BOTTOM_RIGHT = "bottom-right"
    BOTTOM_LEFT = "bottom-left"
    TOP_CENTER = "top-center"
    BOTTOM_CENTER = "bottom-center"

@dataclass
class Notification:
    id: str
    type: NotificationType
    title: str
    message: str
    timestamp: datetime
    duration: int = 5000  # milliseconds
    action_label: Optional[str] = None
    action_callback: Optional[Callable] = None

class NotificationManager:
    """ÏïåÎ¶º Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        if 'notifications' not in st.session_state:
            st.session_state.notifications = []
        if 'notification_settings' not in st.session_state:
            st.session_state.notification_settings = {
                'enabled': True,
                'position': ToastPosition.TOP_RIGHT,
                'default_duration': 5000
            }
    
    def add_notification(self, 
                        type: NotificationType, 
                        title: str, 
                        message: str,
                        duration: int = None,
                        action_label: str = None,
                        action_callback: Callable = None) -> str:
        """ÏïåÎ¶º Ï∂îÍ∞Ä"""
        notification_id = str(uuid.uuid4())
        
        notification = Notification(
            id=notification_id,
            type=type,
            title=title,
            message=message,
            timestamp=datetime.now(),
            duration=duration or st.session_state.notification_settings['default_duration'],
            action_label=action_label,
            action_callback=action_callback
        )
        
        st.session_state.notifications.append(notification)
        return notification_id
    
    def remove_notification(self, notification_id: str):
        """ÏïåÎ¶º Ï†úÍ±∞"""
        st.session_state.notifications = [
            n for n in st.session_state.notifications 
            if n.id != notification_id
        ]
    
    def render_notifications(self):
        """ÏïåÎ¶º Î†åÎçîÎßÅ"""
        if not st.session_state.notification_settings['enabled']:
            return
        
        notifications = st.session_state.notifications.copy()
        current_time = datetime.now()
        
        # ÎßåÎ£åÎêú ÏïåÎ¶º Ï†úÍ±∞
        active_notifications = [
            n for n in notifications
            if (current_time - n.timestamp).total_seconds() * 1000 < n.duration
        ]
        
        st.session_state.notifications = active_notifications
        
        if not active_notifications:
            return
        
        # ÏïåÎ¶º CSS Ïä§ÌÉÄÏùº
        position = st.session_state.notification_settings['position']
        position_styles = self._get_position_styles(position)
        
        notifications_html = f"""
        <div id="notification-container" style="{position_styles}">
        """
        
        for notification in active_notifications[-5:]:  # ÏµúÎåÄ 5Í∞úÎßå ÌëúÏãú
            icon = self._get_notification_icon(notification.type)
            color = self._get_notification_color(notification.type)
            
            action_button = ""
            if notification.action_label:
                action_button = f"""
                <button onclick="handleNotificationAction('{notification.id}')" 
                        style="background: none; border: 1px solid currentColor; 
                               color: inherit; padding: 4px 12px; border-radius: 4px;
                               font-size: 0.8em; cursor: pointer; margin-left: 8px;">
                    {notification.action_label}
                </button>
                """
            
            notifications_html += f"""
            <div class="notification notification-{notification.type.value}" 
                 style="background: {color['bg']}; border-left: 4px solid {color['border']};
                        color: {color['text']}; padding: 12px 16px; margin-bottom: 8px;
                        border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                        display: flex; align-items: center; justify-content: space-between;
                        animation: slideIn 0.3s ease-out;">
                <div style="display: flex; align-items: center;">
                    <span style="font-size: 1.2em; margin-right: 8px;">{icon}</span>
                    <div>
                        <div style="font-weight: 600; margin-bottom: 2px;">{notification.title}</div>
                        <div style="font-size: 0.9em; opacity: 0.9;">{notification.message}</div>
                    </div>
                </div>
                <div style="display: flex; align-items: center;">
                    {action_button}
                    <button onclick="removeNotification('{notification.id}')" 
                            style="background: none; border: none; color: inherit; 
                                   font-size: 1.2em; cursor: pointer; margin-left: 8px;">
                        √ó
                    </button>
                </div>
            </div>
            """
        
        notifications_html += """
        </div>
        
        <style>
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .notification:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        </style>
        
        <script>
        function removeNotification(id) {
            // StreamlitÏóêÏÑú Ï†úÍ±∞ÌïòÎäî Î°úÏßÅÏùÄ ÏÑ∏ÏÖò ÏÉÅÌÉúÎ°ú Ï≤òÎ¶¨
            console.log('Remove notification:', id);
        }
        
        function handleNotificationAction(id) {
            console.log('Handle notification action:', id);
        }
        </script>
        """
        
        st.markdown(notifications_html, unsafe_allow_html=True)
    
    def _get_position_styles(self, position: ToastPosition) -> str:
        """ÏúÑÏπòÎ≥Ñ Ïä§ÌÉÄÏùº"""
        base_style = "position: fixed; z-index: 1000; max-width: 400px; min-width: 300px;"
        
        position_map = {
            ToastPosition.TOP_RIGHT: "top: 20px; right: 20px;",
            ToastPosition.TOP_LEFT: "top: 20px; left: 20px;",
            ToastPosition.BOTTOM_RIGHT: "bottom: 20px; right: 20px;",
            ToastPosition.BOTTOM_LEFT: "bottom: 20px; left: 20px;",
            ToastPosition.TOP_CENTER: "top: 20px; left: 50%; transform: translateX(-50%);",
            ToastPosition.BOTTOM_CENTER: "bottom: 20px; left: 50%; transform: translateX(-50%);"
        }
        
        return base_style + position_map.get(position, position_map[ToastPosition.TOP_RIGHT])
    
    def _get_notification_icon(self, type: NotificationType) -> str:
        """ÏïåÎ¶º ÌÉÄÏûÖÎ≥Ñ ÏïÑÏù¥ÏΩò"""
        icons = {
            NotificationType.SUCCESS: "‚úÖ",
            NotificationType.WARNING: "‚ö†Ô∏è",
            NotificationType.ERROR: "‚ùå",
            NotificationType.INFO: "‚ÑπÔ∏è"
        }
        return icons.get(type, "üì¢")
    
    def _get_notification_color(self, type: NotificationType) -> Dict[str, str]:
        """ÏïåÎ¶º ÌÉÄÏûÖÎ≥Ñ ÏÉâÏÉÅ"""
        colors = {
            NotificationType.SUCCESS: {
                "bg": "rgba(16, 185, 129, 0.1)",
                "border": "#10b981",
                "text": "#065f46"
            },
            NotificationType.WARNING: {
                "bg": "rgba(245, 158, 11, 0.1)",
                "border": "#f59e0b",
                "text": "#92400e"
            },
            NotificationType.ERROR: {
                "bg": "rgba(239, 68, 68, 0.1)",
                "border": "#ef4444",
                "text": "#991b1b"
            },
            NotificationType.INFO: {
                "bg": "rgba(59, 130, 246, 0.1)",
                "border": "#3b82f6",
                "text": "#1e3a8a"
            }
        }
        return colors.get(type, colors[NotificationType.INFO])

class ProgressTracker:
    """ÏßÑÌñâÎ•† Ï∂îÏ†ÅÍ∏∞"""
    
    def __init__(self, title: str, total_steps: int):
        self.title = title
        self.total_steps = total_steps
        self.current_step = 0
        self.start_time = datetime.now()
        self.step_times = []
        
        # ÏßÑÌñâÎ•† Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
        self.container = st.empty()
        self.status_container = st.empty()
    
    def update(self, step: int, message: str = ""):
        """ÏßÑÌñâÎ•† ÏóÖÎç∞Ïù¥Ìä∏"""
        self.current_step = step
        self.step_times.append(datetime.now())
        
        progress_percentage = (step / self.total_steps) * 100
        
        # ÏòàÏÉÅ ÏôÑÎ£å ÏãúÍ∞Ñ Í≥ÑÏÇ∞
        if len(self.step_times) > 1:
            avg_step_time = sum([
                (self.step_times[i] - self.step_times[i-1]).total_seconds()
                for i in range(1, len(self.step_times))
            ]) / (len(self.step_times) - 1)
            
            remaining_steps = self.total_steps - step
            eta = datetime.now() + timedelta(seconds=avg_step_time * remaining_steps)
            eta_text = eta.strftime("%H:%M:%S")
        else:
            eta_text = "Í≥ÑÏÇ∞ Ï§ë..."
        
        # ÏßÑÌñâÎ•† Î∞î
        self.container.progress(progress_percentage / 100, text=f"{self.title} - {step}/{self.total_steps} ({progress_percentage:.1f}%)")
        
        # ÏÉÅÌÉú Ï†ïÎ≥¥
        elapsed_time = (datetime.now() - self.start_time).total_seconds()
        status_html = f"""
        <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin: 8px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>{message or f"Îã®Í≥Ñ {step}/{self.total_steps}"}</strong>
                </div>
                <div style="text-align: right; font-size: 0.9em; color: #666;">
                    <div>Í≤ΩÍ≥º ÏãúÍ∞Ñ: {elapsed_time:.1f}Ï¥à</div>
                    <div>ÏòàÏÉÅ ÏôÑÎ£å: {eta_text}</div>
                </div>
            </div>
        </div>
        """
        
        self.status_container.markdown(status_html, unsafe_allow_html=True)
    
    def complete(self, success_message: str = "ÏôÑÎ£å!"):
        """ÏôÑÎ£å Ï≤òÎ¶¨"""
        self.container.progress(1.0, text=f"{self.title} - ÏôÑÎ£å!")
        
        total_time = (datetime.now() - self.start_time).total_seconds()
        completion_html = f"""
        <div style="background: #d1fae5; border: 1px solid #10b981; padding: 12px; 
                    border-radius: 8px; margin: 8px 0;">
            <div style="color: #065f46;">
                <strong>‚úÖ {success_message}</strong>
                <br>
                <small>Ï¥ù ÏÜåÏöî ÏãúÍ∞Ñ: {total_time:.1f}Ï¥à</small>
            </div>
        </div>
        """
        
        self.status_container.markdown(completion_html, unsafe_allow_html=True)

class LoadingSpinner:
    """Î°úÎî© Ïä§ÌîºÎÑà"""
    
    def __init__(self, message: str = "Î°úÎî© Ï§ë..."):
        self.message = message
        self.container = st.empty()
        self.is_active = False
    
    def start(self):
        """Ïä§ÌîºÎÑà ÏãúÏûë"""
        self.is_active = True
        spinner_html = f"""
        <div style="display: flex; flex-direction: column; align-items: center; 
                    padding: 20px; margin: 20px 0;">
            <div style="border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
                        border-radius: 50%; width: 40px; height: 40px;
                        animation: spin 1s linear infinite;">
            </div>
            <div style="margin-top: 16px; font-weight: 500; color: #666;">
                {self.message}
            </div>
        </div>
        
        <style>
        @keyframes spin {{
            0% {{ transform: rotate(0deg); }}
            100% {{ transform: rotate(360deg); }}
        }}
        </style>
        """
        
        self.container.markdown(spinner_html, unsafe_allow_html=True)
    
    def stop(self):
        """Ïä§ÌîºÎÑà Ï§ëÏßÄ"""
        self.is_active = False
        self.container.empty()
    
    def __enter__(self):
        self.start()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.stop()

class InteractiveTable:
    """Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÌÖåÏù¥Î∏î"""
    
    def __init__(self, data: pd.DataFrame, key: str = None):
        self.data = data
        self.key = key or str(uuid.uuid4())
        self.filtered_data = data.copy()
    
    def render(self, 
               show_filters: bool = True,
               show_export: bool = True,
               show_pagination: bool = True,
               page_size: int = 50,
               selectable: bool = False) -> Dict[str, Any]:
        """ÌÖåÏù¥Î∏î Î†åÎçîÎßÅ"""
        
        result = {
            'filtered_data': self.filtered_data,
            'selected_rows': [],
            'export_data': None
        }
        
        # ÏÉÅÎã® Ïª®Ìä∏Î°§
        if show_filters or show_export:
            col1, col2, col3 = st.columns([2, 2, 1])
            
            with col1:
                if show_filters:
                    search_query = st.text_input(
                        "üîç Í≤ÄÏÉâ", 
                        placeholder="ÌÖåÏù¥Î∏î Í≤ÄÏÉâ...",
                        key=f"table_search_{self.key}"
                    )
                    
                    if search_query:
                        self.filtered_data = self._apply_search(search_query)
            
            with col2:
                if show_filters and len(self.data.select_dtypes(include=['object']).columns) > 0:
                    categorical_cols = self.data.select_dtypes(include=['object']).columns
                    filter_col = st.selectbox(
                        "ÌïÑÌÑ∞ Ïª¨Îüº",
                        ["Ï†ÑÏ≤¥"] + categorical_cols.tolist(),
                        key=f"table_filter_col_{self.key}"
                    )
                    
                    if filter_col != "Ï†ÑÏ≤¥":
                        unique_values = self.data[filter_col].unique()
                        selected_values = st.multiselect(
                            "Í∞í ÏÑ†ÌÉù",
                            unique_values,
                            default=unique_values,
                            key=f"table_filter_values_{self.key}"
                        )
                        
                        if selected_values != list(unique_values):
                            self.filtered_data = self.filtered_data[
                                self.filtered_data[filter_col].isin(selected_values)
                            ]
            
            with col3:
                if show_export:
                    export_format = st.selectbox(
                        "ÎÇ¥Î≥¥ÎÇ¥Í∏∞",
                        ["ÏÑ†ÌÉù", "CSV", "Excel", "JSON"],
                        key=f"table_export_{self.key}"
                    )
                    
                    if export_format != "ÏÑ†ÌÉù":
                        result['export_data'] = {
                            'format': export_format,
                            'data': self.filtered_data
                        }
        
        # ÌÖåÏù¥Î∏î Ï†ïÎ≥¥
        total_rows = len(self.data)
        filtered_rows = len(self.filtered_data)
        
        info_html = f"""
        <div style="background: #f8f9fa; padding: 8px 12px; border-radius: 4px; 
                    margin: 8px 0; font-size: 0.9em; color: #666;">
            ÌëúÏãú Ï§ë: {filtered_rows:,}Í∞ú (Ï†ÑÏ≤¥ {total_rows:,}Í∞ú Ï§ë)
            {f" | Ïª¨Îüº: {len(self.filtered_data.columns)}Í∞ú" if not self.filtered_data.empty else ""}
        </div>
        """
        st.markdown(info_html, unsafe_allow_html=True)
        
        # ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò
        if show_pagination and len(self.filtered_data) > page_size:
            total_pages = (len(self.filtered_data) - 1) // page_size + 1
            
            col1, col2, col3 = st.columns([1, 2, 1])
            
            with col1:
                page_number = st.number_input(
                    "ÌéòÏù¥ÏßÄ",
                    min_value=1,
                    max_value=total_pages,
                    value=1,
                    key=f"table_page_{self.key}"
                )
            
            with col2:
                st.write(f"ÌéòÏù¥ÏßÄ {page_number} / {total_pages}")
            
            with col3:
                page_size = st.selectbox(
                    "ÌéòÏù¥ÏßÄ ÌÅ¨Í∏∞",
                    [25, 50, 100, 200],
                    index=1,
                    key=f"table_page_size_{self.key}"
                )
            
            start_idx = (page_number - 1) * page_size
            end_idx = start_idx + page_size
            display_data = self.filtered_data.iloc[start_idx:end_idx]
        else:
            display_data = self.filtered_data
        
        # ÌÖåÏù¥Î∏î ÌëúÏãú
        if selectable:
            # ÏÑ†ÌÉù Í∞ÄÎä•Ìïú ÌÖåÏù¥Î∏î
            selection = st.dataframe(
                display_data,
                use_container_width=True,
                hide_index=True,
                selection_mode="multi-row",
                on_select="rerun",
                key=f"table_selection_{self.key}"
            )
            
            if hasattr(selection, 'selection') and selection.selection.get('rows'):
                selected_indices = selection.selection['rows']
                result['selected_rows'] = display_data.iloc[selected_indices]
        else:
            st.dataframe(
                display_data,
                use_container_width=True,
                hide_index=True
            )
        
        result['filtered_data'] = self.filtered_data
        return result
    
    def _apply_search(self, query: str) -> pd.DataFrame:
        """Í≤ÄÏÉâ Ï†ÅÏö©"""
        if not query:
            return self.data
        
        masks = []
        for col in self.data.select_dtypes(include=['object', 'string']).columns:
            mask = self.data[col].astype(str).str.contains(query, case=False, na=False)
            masks.append(mask)
        
        if masks:
            combined_mask = masks[0]
            for mask in masks[1:]:
                combined_mask = combined_mask | mask
            
            return self.data[combined_mask]
        
        return self.data

class SmartSuggestions:
    """Ïä§ÎßàÌä∏ Ï†úÏïà ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        if 'user_actions' not in st.session_state:
            st.session_state.user_actions = []
        if 'suggestion_settings' not in st.session_state:
            st.session_state.suggestion_settings = {
                'enabled': True,
                'frequency': 'smart',  # always, smart, minimal
                'categories': ['performance', 'workflow', 'insights']
            }
    
    def log_action(self, action_type: str, context: Dict[str, Any]):
        """ÏÇ¨Ïö©Ïûê Ïï°ÏÖò Î°úÍπÖ"""
        action = {
            'type': action_type,
            'context': context,
            'timestamp': datetime.now().isoformat(),
            'session_id': st.session_state.get('session_id', 'unknown')
        }
        
        st.session_state.user_actions.append(action)
        
        # ÏµúÍ∑º 100Í∞ú Ïï°ÏÖòÎßå Ïú†ÏßÄ
        if len(st.session_state.user_actions) > 100:
            st.session_state.user_actions = st.session_state.user_actions[-100:]
    
    def generate_suggestions(self, current_context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Ï†úÏïà ÏÉùÏÑ±"""
        if not st.session_state.suggestion_settings['enabled']:
            return []
        
        suggestions = []
        recent_actions = st.session_state.user_actions[-10:]  # ÏµúÍ∑º 10Í∞ú Ïï°ÏÖò
        
        # ÏÑ±Îä• Ï†úÏïà
        if 'performance' in st.session_state.suggestion_settings['categories']:
            perf_suggestions = self._generate_performance_suggestions(recent_actions, current_context)
            suggestions.extend(perf_suggestions)
        
        # ÏõåÌÅ¨ÌîåÎ°úÏö∞ Ï†úÏïà
        if 'workflow' in st.session_state.suggestion_settings['categories']:
            workflow_suggestions = self._generate_workflow_suggestions(recent_actions, current_context)
            suggestions.extend(workflow_suggestions)
        
        # Ïù∏ÏÇ¨Ïù¥Ìä∏ Ï†úÏïà
        if 'insights' in st.session_state.suggestion_settings['categories']:
            insight_suggestions = self._generate_insight_suggestions(recent_actions, current_context)
            suggestions.extend(insight_suggestions)
        
        return suggestions[:5]  # ÏµúÎåÄ 5Í∞ú Ï†úÏïà
    
    def render_suggestions(self, context: Dict[str, Any]):
        """Ï†úÏïà Î†åÎçîÎßÅ"""
        suggestions = self.generate_suggestions(context)
        
        if not suggestions:
            return
        
        st.markdown("### üí° Ïä§ÎßàÌä∏ Ï†úÏïà")
        
        for i, suggestion in enumerate(suggestions):
            with st.expander(f"üí° {suggestion['title']}", expanded=i == 0):
                st.write(suggestion['description'])
                
                if suggestion.get('action_label'):
                    if st.button(suggestion['action_label'], key=f"suggestion_action_{i}"):
                        if suggestion.get('action_callback'):
                            suggestion['action_callback']()
                        st.success("Ï†úÏïàÏù¥ Ï†ÅÏö©ÎêòÏóàÏäµÎãàÎã§!")
                
                # Ï†úÏïà ÌèâÍ∞Ä
                col1, col2, col3 = st.columns(3)
                with col1:
                    if st.button("üëç ÎèÑÏõÄÎê®", key=f"suggestion_helpful_{i}"):
                        self._rate_suggestion(suggestion['id'], 'helpful')
                with col2:
                    if st.button("üëé ÎèÑÏõÄÏïàÎê®", key=f"suggestion_not_helpful_{i}"):
                        self._rate_suggestion(suggestion['id'], 'not_helpful')
                with col3:
                    if st.button("üö´ Ï†úÏïà Ïà®Í∏∞Í∏∞", key=f"suggestion_hide_{i}"):
                        self._hide_suggestion(suggestion['id'])
    
    def _generate_performance_suggestions(self, recent_actions: List[Dict], context: Dict) -> List[Dict]:
        """ÏÑ±Îä• Í∞úÏÑ† Ï†úÏïà"""
        suggestions = []
        
        # Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ Í∏∞Î∞ò Ï†úÏïà
        if context.get('data_size', 0) > 10000:
            suggestions.append({
                'id': 'perf_large_data',
                'title': 'ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞ ÏµúÏ†ÅÌôî',
                'description': 'ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞Í∞Ä ÌÅ¨Îãà ÏÉòÌîåÎßÅÏù¥ÎÇò Î∞∞Ïπò Ï≤òÎ¶¨Î•º Í≥†Î†§Ìï¥Î≥¥ÏÑ∏Ïöî.',
                'category': 'performance',
                'action_label': 'ÏÉòÌîåÎßÅ Ï†ÅÏö©',
                'action_callback': lambda: st.info("Îç∞Ïù¥ÌÑ∞ ÏÉòÌîåÎßÅÏù¥ Ï†ÅÏö©Îê©ÎãàÎã§.")
            })
        
        # Î∞òÎ≥µÏ†ÅÏù∏ Í≥ÑÏÇ∞ Í∞êÏßÄ
        calc_actions = [a for a in recent_actions if a['type'] in ['calculate', 'analyze']]
        if len(calc_actions) > 3:
            suggestions.append({
                'id': 'perf_caching',
                'title': 'Í≥ÑÏÇ∞ Í≤∞Í≥º Ï∫êÏã±',
                'description': 'Î∞òÎ≥µÏ†ÅÏù∏ Í≥ÑÏÇ∞ÏùÑ Í∞êÏßÄÌñàÏäµÎãàÎã§. Ï∫êÏã±ÏùÑ ÌôúÏÑ±ÌôîÌïòÎ©¥ ÏÜçÎèÑÍ∞Ä Ìñ•ÏÉÅÎê©ÎãàÎã§.',
                'category': 'performance',
                'action_label': 'Ï∫êÏã± ÌôúÏÑ±Ìôî',
                'action_callback': lambda: st.info("Ï∫êÏã±Ïù¥ ÌôúÏÑ±ÌôîÎê©ÎãàÎã§.")
            })
        
        return suggestions
    
    def _generate_workflow_suggestions(self, recent_actions: List[Dict], context: Dict) -> List[Dict]:
        """ÏõåÌÅ¨ÌîåÎ°úÏö∞ Í∞úÏÑ† Ï†úÏïà"""
        suggestions = []
        
        # ÌïÑÌÑ∞ ÏÇ¨Ïö© Ìå®ÌÑ¥ Î∂ÑÏÑù
        filter_actions = [a for a in recent_actions if a['type'] == 'filter']
        if len(filter_actions) > 2:
            suggestions.append({
                'id': 'workflow_save_filter',
                'title': 'ÌïÑÌÑ∞ Ï†ÄÏû•',
                'description': 'ÏûêÏ£º ÏÇ¨Ïö©ÌïòÎäî ÌïÑÌÑ∞ Ï°∞Í±¥ÏùÑ Ï†ÄÏû•ÌïòÏó¨ Îπ†Î•¥Í≤å Ïû¨ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.',
                'category': 'workflow',
                'action_label': 'ÌòÑÏû¨ ÌïÑÌÑ∞ Ï†ÄÏû•',
                'action_callback': lambda: st.info("ÌïÑÌÑ∞Í∞Ä Ï†ÄÏû•Îê©ÎãàÎã§.")
            })
        
        return suggestions
    
    def _generate_insight_suggestions(self, recent_actions: List[Dict], context: Dict) -> List[Dict]:
        """Ïù∏ÏÇ¨Ïù¥Ìä∏ Ï†úÏïà"""
        suggestions = []
        
        # Îç∞Ïù¥ÌÑ∞ Ìå®ÌÑ¥ Í∏∞Î∞ò Ï†úÏïà
        if context.get('has_time_series'):
            suggestions.append({
                'id': 'insight_trend_analysis',
                'title': 'Ìä∏Î†åÎìú Î∂ÑÏÑù',
                'description': 'ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞Í∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§. Ìä∏Î†åÎìú Î∂ÑÏÑùÏùÑ ÏàòÌñâÌï¥Î≥¥ÏÑ∏Ïöî.',
                'category': 'insights',
                'action_label': 'Ìä∏Î†åÎìú Î∂ÑÏÑù ÏãúÏûë',
                'action_callback': lambda: st.info("Ìä∏Î†åÎìú Î∂ÑÏÑùÏùÑ ÏãúÏûëÌï©ÎãàÎã§.")
            })
        
        return suggestions
    
    def _rate_suggestion(self, suggestion_id: str, rating: str):
        """Ï†úÏïà ÌèâÍ∞Ä"""
        if 'suggestion_ratings' not in st.session_state:
            st.session_state.suggestion_ratings = {}
        
        st.session_state.suggestion_ratings[suggestion_id] = {
            'rating': rating,
            'timestamp': datetime.now().isoformat()
        }
    
    def _hide_suggestion(self, suggestion_id: str):
        """Ï†úÏïà Ïà®Í∏∞Í∏∞"""
        if 'hidden_suggestions' not in st.session_state:
            st.session_state.hidden_suggestions = set()
        
        st.session_state.hidden_suggestions.add(suggestion_id)

# Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§
notification_manager = NotificationManager()
smart_suggestions = SmartSuggestions()

def create_success_toast(title: str, message: str):
    """ÏÑ±Í≥µ ÌÜ†Ïä§Ìä∏ ÏÉùÏÑ±"""
    notification_manager.add_notification(NotificationType.SUCCESS, title, message)

def create_warning_toast(title: str, message: str):
    """Í≤ΩÍ≥† ÌÜ†Ïä§Ìä∏ ÏÉùÏÑ±"""
    notification_manager.add_notification(NotificationType.WARNING, title, message)

def create_error_toast(title: str, message: str):
    """ÏóêÎü¨ ÌÜ†Ïä§Ìä∏ ÏÉùÏÑ±"""
    notification_manager.add_notification(NotificationType.ERROR, title, message)

def create_info_toast(title: str, message: str):
    """Ï†ïÎ≥¥ ÌÜ†Ïä§Ìä∏ ÏÉùÏÑ±"""
    notification_manager.add_notification(NotificationType.INFO, title, message)